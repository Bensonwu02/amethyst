########################################################################################################
### PACKAGE INSTALLATION ###

If you are new to R, you may need to install some of the dependencies:
```{r} 
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install()

library(BiocManager)
BiocManager::install(c("data.table", "dplyr", "furrr", "future", 
  "ggplot2", "grDevices", "gridExtra", "igraph", "irlba", "janitor", "methods", 
  "plotly", "plyr", "purrr", "rhdf5", "rtracklayer", "scales", "stats", "stringr", 
  "tibble", "tidyr", "umap", "utils"))
```

Next, install a few additional dependencies only found on Github as well as amethyst itself.

```{r}
install.packages("devtools")
devtools::install_github("JinmiaoChenLab/Rphenograph")
devtools::install_github("KrishnaswamyLab/MAGIC/Rmagic")
devtools::install_github("lrylaarsdam/amethyst")
library(amethyst)
```

These will also be helpful to have:

```{r}
library(data.table)
library(ggplot2)
library(dplyr)
library(tibble)
library(tidyr)
library(plyr)
library(future)
library(furrr)
library(purrr)
library(cowplot)
```

########################################################################################################
### LOADING PRACTICE DATA ###

First, download the practice data. This vignette comes with site-level CpG methylation information from 50 human banked PBMCs. Download the h5 file and associated metadata with the following commands.
* Note: These commands will download to the current directory. setwd(["/path/to/directory"]) if a different directory is desired.

```{r}
download.file("https://adeylabopen.s3.us-west-2.amazonaws.com/amethyst/pbmc_vignette.h5", "./pbmc_vignette.h5", method = "curl") # Contains site-level methylation information for each cell
download.file("https://raw.githubusercontent.com/lrylaarsdam/amethyst/dev/pbmc_vignette/pbmc_vignette_cellInfo.txt", "./pbmc_vignette_cellInfo.txt") # Summary QC statistics for each cell
download.file("https://raw.githubusercontent.com/lrylaarsdam/amethyst/dev/pbmc_vignette/pbmc_vignette.annot", "./pbmc_vignette.annot") # Simulated batch metadata
```

########################################################################################################
### ASSEMBLING THE AMETHYST OBJECT ###

Now construct an amethyst object, which stores the path to the h5 file as well as a lot of other information that will be calculated downstream.

```{r}
obj <- createObject()
```

Next, we need to add metadata about each cell. Useful metadata includes quality control metrics contained in the .cellInfo.txt intermediate output or .annot files, if using the Adey lab Premethyst workflow.

```{r}
obj <- addCellInfo(obj, file = "./pbmc_vignette_cellInfo.txt")
obj <- addAnnot(obj, file = "./pbmc_vignette.annot", name = "batch") 
head(obj@metadata)
```

While not essential, it can be helpful to filter cells with outlying coverage values right away so downstream functions don't perform calculations for cells that will not be used. This can easily be done with dplyr logic. First, view the coverage distribution, then filter as necessary.

* Note: vignette data has been pre-filtered. We recommend cells have a minimum of 1M cytosines covered.

```{r}
ggplot(obj@metadata, aes(x = cov)) + geom_histogram(bins = 10) 
obj@metadata <- obj@metadata |> dplyr::filter(cov > 100000 & cov < 40000000)
```

Next, we need to specify the location of the h5 file containing site-level methylation data for each barcode. In this case, every barcode belongs to the same h5 file, but an unlimited number of h5 files can be used in the same object. Row names are barcodes and the "paths" column specifies each path.

```{r}
obj@h5paths <- data.frame(row.names = rownames(obj@metadata), paths = rep("./pbmc_vignette.h5", length(rownames(obj@metadata))))
head(obj@h5paths)
```

########################################################################################################
### CLUSTERING ###

The next step is to cluster cells, which we typically do based on methylation values over fixed genomic windows. 
An initial indexing helps reduce the computational load by determining the locations corresponding to each chromosome in every h5 file and only calculating across one at a time.

* Note: You may have to copy/paste any code reading the h5 file (e.g., makeWindows) directly into the console instead of running the chunk
```{r}
obj@index[["chr_cg"]] <- indexChr(obj, type = "CG", threads = 1) # This would usually take place with a lot more threads
obj@genomeMatrices[["cg_100k_score"]] <- makeWindows(obj, # Amethyst object to calculate methylation levels over
                                                     stepsize = 100000, # Width of the genomic window to calculate methylation levels over
                                                     type = "CG", # What type of methylation to retrieve; i.e. "CH" or "CG"
                                                     metric = "score", # 	Calculate either methylation percent, score, or ratio
                                                     threads = 1, # When analyzing a larger dataset, multithreading is recommended for this step
                                                     index = "chr_cg", # Name of the stored indexes calculated in the previous step
                                                     nmin = 2, # Minimum number of observations for the window to be included
                                                     species = "human") # Species of data - needed for chromosome number
```

You may want to remove windows where many values are NA. The appropriate threshold will highly depend on how big the windows are and how many cells you have.
In this case, since the vignette data is high coverage and the genomic windows are large, I am going to filter for at least 90% of the cells have values in that window.

```{r}
obj@genomeMatrices[["cg_100k_score"]] <- obj@genomeMatrices[["cg_100k_score"]][rowSums(!is.na(obj@genomeMatrices[["cg_100k_score"]])) >= 45, ]
```

Next, perform dimensionality reduction with irlba. If you are unsure how many dimensions to use, the dimEstimate function can estimate the number needed to explain the desired variance threshold.
*Note: In this example, the number of requested output dimensions is low because brain_vignette.h5 has 50 cells. 

```{r}
dimEstimate(obj, genomeMatrices = c("cg_100k_score"), dims = c(10), threshold = 0.95)
```

As suggested, we will reduce the data from obj@genomeMatrices[["cg_100k_score"]] into seven dimensions using the irlba package, which performs fast truncated singular value decomposition.

```{r}
obj@reductions[["irlba"]] <- runIrlba(obj, genomeMatrices = c("cg_100k_score"), dims = c(7), replaceNA = c(0))
obj@reductions[["irlba_regressed"]] <- regressCovBias(obj, reduction = "irlba") # Optional; helps reduce coverage bias in clustering
```

Now determine cluster membership using the Rphenograph package.
*Note: In this example, k_phenograph and neighbors parameters are low because brain_vignette.h5 has 50 cells.

```{r}
set.seed(123)
obj <- runCluster(obj, k_phenograph = 10, reduction = "irlba_regressed") # consider increasing k_phenograph to 50 for larger datasets
```
Umap and tsne are dimensionality reduction techniques frequently used to collapse higher-order information into two or three
coordinates for visualization of single-cell data. Either or both methods can be used as input for dimensionality reduction-
based visualization functions like dimFeature. 

```{r}
obj <- runUmap(obj, neighbors = 5, dist = 0.05, method = "euclidean", reduction = "irlba_regressed") 
obj <- runTsne(obj, perplexity = 10, method = "euclidean", theta = 0.5, reduction = "irlba_regressed") 
```

### Visualizing the results ###
First, plot the UMAP or TSNE coordinates of the cells with the color corresponding to cluster membership.

```{r}
p1 <- dimFeature(obj, colorBy = cluster_id, reduction = "umap") + ggtitle("UMAP")
p2 <- dimFeature(obj, colorBy = cluster_id, reduction = "tsne") + ggtitle("TSNE")
plot_grid(p1, p2)
```

You might find that fixed genomic windows don't give you good resolution of groups. Any feature set can be used for dimensionality reduction input.
The makeWindows function can also calculate methylation levels over a bed file or genes (not recommended unless you are calculating %mCH.)
Here is another clustering example using a set of pre-identified PBMC differentially methylated regions (DMRs).

```{r}
download.file("https://raw.githubusercontent.com/lrylaarsdam/amethyst/dev/pbmc_vignette/pbmc_highconfidence_dmrs.bed", "./pbmc_dmr.bed") 
obj@genomeMatrices[["pbmc_dmrs"]] <- makeWindows(obj, bed = "./pbmc_dmr.bed", type = "CG", metric = "percent", threads = 1, index = "chr_cg", nmin = 2, species = "human")
obj@genomeMatrices[["pbmc_dmrs"]] <- obj@genomeMatrices[["pbmc_dmrs"]][rowSums(!is.na(obj@genomeMatrices[["pbmc_dmrs"]])) >= 10, ] 
dimEstimate(obj, genomeMatrices = c("pbmc_dmrs"), dims = c(10), threshold = 0.90) # 7
obj@reductions[["irlba"]] <- runIrlba(obj, genomeMatrices = c("pbmc_dmrs"), dims = c(8), replaceNA = c(0))
obj@reductions[["irlba_regressed"]] <- regressCovBias(obj, reduction = "irlba")
obj <- runCluster(obj, k_phenograph = 10, reduction = "irlba_regressed") # consider increasing k_phenograph to 50 for larger datasets
obj <- runUmap(obj, neighbors = 5, dist = 0.05, method = "euclidean", reduction = "irlba_regressed") 
```

```{r}
dimFeature(obj, colorBy = cluster_id, reduction = "umap")
```

umapFeature uses ggplot logic, so you can easily modify plots as needed. For example:

```{r}
dimFeature(obj, colorBy = cluster_id) + facet_wrap(vars(batch)) # Batch is simulated to illustrate function utility. Any column in the metadata will work.
```

(Optional) If you want to make the umap/tsne plots look nicer, amethyst provides many built-in color palettes:

```{r}
testPalette(output = "dimFeature", obj = obj)
```

```{r}
testPalette(output = "swatch", n = length(unique(obj@metadata$cluster_id)))
```

```{r}
# Choosing option 7 "#B5DCA5" "#F9AB60" "#630661" "#E7576E"
pal <- makePalette(option = 7, n = 4) 
dimFeature(obj, colorBy = cluster_id, colors = pal, pointSize = 1)
```

umapFeature is useful for looking at how the different parameters in the cellInfo file are distributed throughout the UMAP:

```{r}
p1 <- dimFeature(obj, colorBy = log(cov), pointSize = 1) + scale_color_gradientn(colors = c("black", "turquoise", "gold", "red")) + ggtitle("Coverage distribution")
p2 <- dimFeature(obj, colorBy = mcg_pct, pointSize = 1) + scale_color_gradientn(colors = c("black", "turquoise", "gold", "red")) + ggtitle("Global %mCG distribution")
plot_grid(p1, p2)
```

Show the distribution of cluster membership between samples with sampleComp. Plots can be easily modified with ggplot command logic.

```{r}
sampleComp(obj, groupBy = "batch", colorBy = "cluster_id", colors = pal) 
```

########################################################################################################
### ANNOTATION ###

Now that we have clusters, the next step is annotation. There are a couple ways to do this:

1) One useful method is to look at mCG hypomethylation over canonical marker genes. We recommend visualizing mCG patterns over the entire gene body. 
The first step is to load an annotation file for the reference genome so amethyst knows the coordinates for each gene.

```{r}
obj@ref <- makeRef("hg38")
```

Next, calculate methylation levels in short genomic windows for each cluster. We recommend 500bp windows, but 1kb are used here since the dataset is smaller.

```{r}
cluster1kbwindows <- calcSmoothedWindows(obj, 
                                         type = "CG", 
                                         threads = 1,
                                         step = 1000,
                                         smooth = 3,
                                         species = "human",
                                         index = "chr_cg",
                                         groupBy = "cluster_id",
                                         returnSumMatrix = TRUE, # save sum matrix for DMR analysis
                                         returnPctMatrix = TRUE)
obj@genomeMatrices[["cg_cluster_tracks"]] <- cluster1kbwindows[["pct_matrix"]]
```

Now you can view methylation patterns over key marker genes:

```{r}
heatMap(obj, 
        genes = c("SPI1", "CD2", "S100A8",  "CD79A", "CD3G", "ELANE", "MPO", 
           "S100A8", "MPEG1", "IRF8", "CD74", "GZMK", "CD3E", "CD3D", "KIR2DL4", "KLRB1"), 
        matrix = "cg_cluster_tracks", 
        nrow = 4,
        legend = FALSE,
        width = 1000)
```

As you can see from the heatMaps, promoters are often universally hypomethylated or not at the predicted site,
but it can still be useful to look at aggregated promoter metrics. 

To calculate %mCG for promoter regions (in this example all protein coding genes, but a subset can easily be used):

```{r}
protein_coding <- unique(obj@ref |> dplyr::filter(type == "gene" & gene_type == "protein_coding" & seqid != "chrM") |> dplyr::pull(gene_name))
obj@genomeMatrices[["cg_promoter"]] <- makeWindows(obj, # Amethyst object to calculate methylation levels over
                                                     genes = protein_coding, # Width of the genomic window to calculate methylation levels over
                                                     promoter = TRUE, # Calculate methylation levels +/- 1500bp of the (strand-aware) predicted start site
                                                     type = "CG", # What type of methylation to retrieve; i.e. "CH" or "CG"
                                                     metric = "percent", # 	Calculate either methylation percent, score, or ratio
                                                     threads = 1, # When analyzing a larger dataset, multithreading is recommended for this step
                                                     index = "chr_cg", # Name of the stored indexes calculated in the previous step
                                                     nmin = 2, # Minimum number of observations for the window to be included
                                                     species = "human") # Species of data - needed for chromosome number
# subsetting to genes with values in at least 5 cells
obj@genomeMatrices[["cg_promoter"]] <- obj@genomeMatrices[["cg_promoter"]][rowSums(!is.na(obj@genomeMatrices[["cg_promoter"]])) >= 10, ]
```

Now you can view average %mCG of marker gene promoters by cluster:

```{r} 
genes <- c("SPI1", "CD19", "CD2", "CD6", "CD8A", "CD4", "CSF1R", "GATA1", "CD79A", "CD3G", "ELANE", "MPO", "ITGAM",
           "S100A8", "MPEG1", "FN1", "IRF8", "CD74", "RORA", "GZMK", "CD3E", "CD3D", "MEIS1", "KIR2DL4", "KLRB1")
dotM(obj, genes = genes, groupBy = "cluster_id", matrix = "cg_promoter")
```

Again, easily modify with ggplot logic as desired: 

```{r} 
dotM(obj, genes = genes, groupBy = "cluster_id", matrix = "cg_promoter_markers") + 
  scale_color_gradientn(colors =  c("#FF0082", "#dbdbdb", "#cccccc", "#999999")) + scale_size(range = c(1, 8))
```

You can also view mCG patterns in a histogram fashion:

``` {r}
histograM(obj, genes = c("ELANE", "MPEG1", "SPI1", "CD2", "CD3D"), matrix = "cg_cluster_tracks", legend = F, width = 1000)
```

It can also be helpful to use a less directed approach when determining differences between groups. 
For this vignette, we are just testing a subset of known marker genes, but for thorough data analysis it would better to test all protein coding genes.

```{r}
cluster_promoter_markers <- findClusterMarkers(obj, 
                                               matrix = "cg_promoter", 
                                               genes = genes, 
                                               threads = 1)
cluster_promoter_markers <- cluster_promoter_markers |> dplyr::filter(p.adj < 0.05) # Not many results because it's a small dataset
head(cluster_promoter_markers)
```

```{r} 
dotM(obj, genes = cluster_promoter_markers$gene, groupBy = "cluster_id", matrix = "cg_promoter") + 
  scale_color_gradientn(colors =  c("#FF0082", "#dbdbdb", "#cccccc", "#999999")) + scale_size(range = c(1, 12))
```

Another method one could use is by comparison to an annotated reference. 
While few exist, we have put aggregated methylation levels per group over high-confidence PBMC DMRs on Github. 
First download this data and calculate average methylation levels per cluster for each DMR (windows or any feature can also work)

```{r}
download.file("https://raw.githubusercontent.com/lrylaarsdam/amethyst/dev/pbmc_vignette/pbmc_ref.RData", "./pbmc_ref.RData") 
ref <- readRDS("./pbmc_ref.RData")

obj@genomeMatrices[["pbmc_dmrs_aggregated"]] <- aggregateMatrix(obj, matrix = "pbmc_dmrs", groupBy = "cluster_id")
```

Now see correlation profiles
```{r}
cor <- cor(merge(ref, 
                 obj@genomeMatrices[["pbmc_dmrs_aggregated"]], 
                 by = 0) |> tibble::column_to_rownames(var = "Row.names"), use = "pairwise.complete.obs")
cor <- cor[c(1:ncol(ref)), c((ncol(ref) + 1)):ncol(cor)]
pheatmap(cor)
```

Based on all these annotation tools, we can rename our clusters according to broad class using dplyr logic:

```{r}
obj@metadata[["type"]] <- dplyr::recode(obj@metadata[["cluster_id"]],
                                             "1" = "T", 
                                             "2" = "NK", 
                                             "3" = "B",
                                             "4" = "Mono")
dimFeature(obj, colorBy = type, colors = pal, pointSize = 1)
```

You might also want cluster tracks with the group name:

```{r}
obj@genomeMatrices[["cg_type_tracks"]] <- copy(obj@genomeMatrices[["cg_cluster_tracks"]])
setnames(obj@genomeMatrices[["cg_type_tracks"]], c("chr", "start", "end", "T", "NK", "B", "Mono"))
heatMap(obj, 
        genes = c("SPI1", "CD2", "S100A8",  "CD79A", "CD3G", "ELANE", "MPO", 
           "S100A8", "MPEG1", "IRF8", "CD74", "GZMK", "CD3E", "CD3D", "KIR2DL4", "KLRB1"), 
        matrix = "cg_type_tracks", 
        nrow = 4,
        legend = FALSE,
        width = 1000)
```

########################################################################################################
### DIFFERENTIALLY METHYLATED REGION ANALYSIS ###

There are two main formats to set up DMR analysis. The first is to test DMRs for each cluster against all others.
Only the sum matrix (which we saved at the calcSmoothedWindows step) is needed, or regenerate with your annotated cell types:

```{r}
sumMatrix <- calcSmoothedWindows(obj, 
                                         type = "CG", 
                                         threads = 1,
                                         step = 1000,
                                         smooth = 3,
                                         species = "human",
                                         index = "chr_cg",
                                         groupBy = "type",
                                         returnSumMatrix = TRUE, # save sum matrix for DMR analysis
                                         returnPctMatrix = FALSE)
dmrs <- testDMR(sumMatrix, eachVsAll = TRUE, nminTotal = 5, nminGroup = 5) # or use cluster1kbwindows[["sum_matrix"]] and rename
```

Then expand and filter the resulting list according to the desired stringency.

```{r}
dmrs <- filterDMR(dmrs, method = "bonferroni", filter = TRUE, pThreshold = 0.01, logThreshold = 2)
head(dmrs)
```

Especially since the matrix is smoothed, adjacent genomic windows may be significant. You can collapse them with the following function.
The object is needed here for the annotation file.

```{r}
collapsed_dmrs <- collapseDMR(obj, dmrs, maxDist = 4000, minLength = 2000, reduce = T, annotate = T) 
head(collapsed_dmrs)
```

Note: The "test" column indicates which cluster is considered the member group. If you are testing a renamed matrix, you might want to add those names
To your results instead of having the numerical order in which they were tested (which works ok for cluster DMRs). Change sumMatrix if necessary.

```{r}
groups <- as.list(sub("_c$", "", colnames(sumMatrix)[grep("_c$", colnames(sumMatrix))]))
key <- data.frame(test = as.factor(1:length(groups)), 
                 type = unlist(groups))
collapsed_dmrs <- left_join(collapsed_dmrs, key, by = "test")
head(collapsed_dmrs)
```

If specific comparisons are desired, a data frame can be provided describing the tests. Three columns should be included: One listing members of group A, one listing members of group B, and one with the name of the test.

```{r}
comparisons <- data.frame(
  stringsAsFactors = FALSE,
              name = c("test1", "test2", "test3"),
                 A = c("1,2,3", "1", "2,3"),
                 B = c("1,4", "2", "1")
)
dmrs <- testDMR(sumMatrix = cluster1kbwindows[["sum_matrix"]], comparisons = comparisons, nminTotal = 5, nminGroup = 5)
```

########################################################################################################
### INVESTIGATING DMR RESULTS ### 

First, let's look at how many DMRs were identified in each group:

```{r}
ggplot(collapsed_dmrs |> dplyr::group_by(type, direction) |> dplyr::summarise(n = n()), 
       aes(y = type, x = n, fill = type)) + geom_col() + 
  facet_grid(vars(direction), scales = "free_y") + scale_fill_manual(values = pal) + theme_classic()
```

Isolate top results per group 
We find it helpful to select by a combined metric of logFC and padj, but you can modify as necessary:

```{r}
top_dmrs <- collapsed_dmrs |> 
  dplyr::group_by(type, direction) |> 
  dplyr::arrange(dmr_padj, .by_group = TRUE) |> dplyr::mutate(rank_padj = 1:n()) |>
  dplyr::arrange(desc(abs(dmr_logFC)), .by_group = TRUE) |> dplyr::mutate(rank_logFC = 1:n()) |>
  rowwise() |> dplyr::mutate(total_rank = sum(rank_padj, rank_logFC)) |> 
  group_by(test, direction) |> slice_min(n = 1, order_by = total_rank) |>
  dplyr::mutate(location = paste0(chr, "_", (dmr_start - 2000), "_", (dmr_end + 2000))) |> dplyr::arrange(direction)

```

Plotting top hypomethylated regions for each group shows expected patterns based on known marker genes:

```{r}
heatMap(obj, matrix = "cg_type_tracks", regions = top_dmrs$location[top_dmrs$direction == "hypo"], nrow = 2, legend = FALSE, width = 1000, arrowOverhang = 0)
```

########################################################################################################
### GO ANALYSIS ###

Further interpretation of the results can be explored using a wide variety of packages available on R.
In this example, we will use the topGO package to test for Gene Ontology (GO) term enrichments for genes with hypomethylated regions in the T cell group.

``` {r}
library(topGO)
background <- rownames(obj@genomeMatrices[["cg_promoter"]]) # all genes tested 
query <- unlist(strsplit(collapsed_dmrs$gene_names[collapsed_dmrs$type == "T" & collapsed_dmrs$direction == "hypo"], ", "))

GOdata <- new("topGOdata", 
              description = "GO Enrichment Analysis", 
              ontology = "BP", 
              allGenes = setNames(factor(as.integer(background %in% query), levels = c(0, 1)), background),
              geneSel = function(x) x == 1, 
              nodeSize = 10, 
              annot = annFUN.org, 
              mapping = "org.Hs.eg.db", 
              ID = "symbol")
resultElim <- runTest(GOdata, algorithm = "elim", statistic = "fisher")
resultElim <- GenTable(GOdata, Fisher = resultElim, topNodes = 500, numChar = 60)
resultElim <- resultElim |> dplyr::filter(Fisher < 0.01 & Significant > 5) |> dplyr::mutate(fold_change = Significant/Expected, Fisher = as.numeric(Fisher))
resultElim <- janitor::clean_names(resultElim)
```

As expected, top results are strongly related to T cell processes:

```{r}
ggplot(resultElim, aes(x = fold_change, y = reorder(term, fold_change), fill = fisher)) + geom_col() + theme_classic() + scale_fill_viridis_c(direction = -1)
```
########################################################################################################
### CONCLUSION ### 

Thanks for trying out Amethyst!
Additional utilities are still to come. We are also open to suggestions.
Good luck in your analysis!



