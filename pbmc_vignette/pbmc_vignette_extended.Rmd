### PART ONE: RECOMMENDED TO RUN ON THE CLUSTER ###
########################################################################################################
### PACKAGE INSTALLATION ###
If you are working on Adey lab servers, consider adding a pre-assembled library with dependencies to your path:

```{r}
.libPaths('/home/groups/ravnica/env/R_libs/R-4.2.2_amethyst')
```

If you are new to R, you may need to install some of the dependencies:
```{r} 
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.14")

library(BiocManager)
BiocManager::install(c("data.table", "dplyr", "furrr", "future", 
  "ggplot2", "grDevices", "gridExtra", "igraph", "irlba", "janitor", "methods", 
  "plotly", "plyr", "purrr", "rhdf5", "rtracklayer", "scales", "stats", "stringr", 
  "tibble", "tidyr", "umap", "utils"))
```

Next, install a few additional dependencies only found on Github as well as amethyst itself.

```{r}
install.packages("devtools")
devtools::install_github("JinmiaoChenLab/Rphenograph")
devtools::install_github("KrishnaswamyLab/MAGIC/Rmagic")
devtools::install_github("lrylaarsdam/amethyst")
library(amethyst)
```

These will also be helpful to have:

```{r}
library(data.table)
library(ggplot2)
library(dplyr)
library(tibble)
library(tidyr)
library(plyr)
library(future)
library(furrr)
library(purrr)
```

########################################################################################################
### LOADING PRACTICE DATA ###

This vignette comes with a toy dataset of 50 cells derived from human brain cortex. Specify the desired path to store the file. It is 12 GB, since it is high coverage and includes both CG and CH methylation data.

```{r}
# This is the path to the vignette h5 file if using Adey Lab servers
path <- "~/Downloads/PBMC2_amethyst_vignette_50cellsubset.h5" 

# To download from AWS. Modify the desired path in the second command if you don't want it in the working directory.
download.file("https://adeylabopen.s3.us-west-2.amazonaws.com/amethyst/brain_vignette.h5", "brain_vignette.h5", method = "curl") 
path <- "./brain_vignette.h5"
```

Alternatively, many of the commands can be run using just the pre-assembled vignette workspace without the large h5 file. If you download the workspace, all the downstream commands have been run, so you can just explore what is helpful. This is recommended if you don't have cluster access.

```{r}
# This is the path to the vignette workspace if using Adey Lab servers
load("/home/groups/ravnica/projects/amethyst/sciMETv2_braindata/brain_vignette_workspace.RData") 

# Or you can download from AWS. Modify the desired path in the second command if you don't want it in the working directory.
download.file("https://adeylabopen.s3.us-west-2.amazonaws.com/amethyst/brain_vignette_workspace.RData", "brain_vignette_workspace.RData", method = "curl") 
load("./brain_vignette_workspace.RData")
```

########################################################################################################
### ASSEMBLING THE AMETHYST OBJECT ###

Now construct an amethyst object, which stores the path to the h5 file as well as a lot of other information that will be calculated downstream.

```{r}
obj <- createObject()
```

Next, we need to add metadata about each cell. Useful metadata includes quality control metrics contained in the .cellInfo.txt intermediate output or .annot files, if using the Adey lab workflow.

```{r}
obj <- addCellInfo(obj, file = "~/Downloads/brain_vignette_cellInfo.txt")
obj <- addAnnot(obj, file = "~/Downloads/brain_vignette.annot", name = "method") 
```

You can now view the information we added to the metadata like this:

```{r}
View(obj@metadata)
```

While not essential, it can be helpful to filter cells right away so downstream functions don't perform calculations
For cells that will not be used. This can easily be done with dplyr logic.

```{r}

obj@metadata <- obj@metadata |> dplyr::filter(cov > 100000 & cov < 40000000)
```

Next, we need to specify the location of the h5 file containing site-level methylation data for each barcode. In this case, every barcode belongs to the same h5 file, but an unlimited number of h5 files can be used in the same object. Row names are barcodes and the "paths" column specifies each path.

```{r}
obj@h5paths <- data.frame(row.names = rownames(obj@metadata), paths = rep(path, length(rownames(obj@metadata))))
head(obj@h5paths)
```

The next step is to cluster cells, which we typically do based on methylation values over fixed genomic windows. 
An initial indexing helps reduce the computational load by determining the locations corresponding to each chromosome in every h5 file and only calculating across one at a time.
*Note: This step is recommended to run on a cluster.

```{r}
obj@index[["chr_cg"]] <- indexChr(obj, type = "CG", threads = 1) # This would usually take place with a lot more threads
obj@genomeMatrices[["cg_100k_score"]] <- makeWindows(obj, stepsize = 100000, type = "CG", metric = "score", threads = 1, index = "chr_cg", nmin = 2, species = "human")
obj@genomeMatrices[["cg_100k_score"]] <- obj@genomeMatrices[["cg_100k_score"]][rowSums(!is.na(obj@genomeMatrices[["cg_100k_score"]])) >= 40, ]

obj@genomeMatrices[["pbmc_dmrs"]] <- makeWindows(obj, bed = "~/Downloads/pbmc_dmr.bed", type = "CG", metric = "score", threads = 1, index = "chr_cg", nmin = 2, species = "human")
obj@genomeMatrices[["pbmc_dmrs"]] <- obj@genomeMatrices[["pbmc_dmrs"]][rowSums(!is.na(obj@genomeMatrices[["pbmc_dmrs"]])) >= 20, ]

```

Next, perform dimensionality reduction with irlba. If you are unsure how many dimensions to use, the dimEstimate function can estimate the number needed to explain the desired variance threshold.
*Note: In this example, the number of requested output dimensions is low because brain_vignette.h5 has 50 cells. 

```{r}
dimEstimate(obj, genomeMatrices = c("pbmc_dmrs"), dims = c(10), threshold = 0.95)
obj@reductions[["irlba"]] <- runIrlba(obj, genomeMatrices = c("pbmc_dmrs"), dims = c(8), replaceNA = c(0))
```

Now determine cluster membership using the Rphenograph package.
*Note: In this example, k_phenograph and neighbors parameters are low because brain_vignette.h5 has 50 cells.

```{r}
obj@reductions[["irlba_regressed"]] <- regressCovBias(obj, reduction = "irlba")
obj <- runCluster(obj, k_phenograph = 5, reduction = "irlba_regressed") # consider increasing k_phenograph to 50 for larger datasets
```

Umap and tsne are dimensionality reduction techniques frequently used to collapse higher-order information into two or three
coordinates for visualization of single-cell data. Either or both methods can be used as input for dimensionality reduction-
based visualization functions like dimFeature. 

```{r}
obj <- runUmap(obj, neighbors = 5, dist = 0.05, method = "euclidean", reduction = "irlba_regressed") 
#obj <- runTsne(obj, perplexity = 30, method = "euclidean", theta = 0.5, reduction = "irlba_regressed") 
```

### Visualizing the results ###
First, plot the UMAP or TSNE coordinates of the cells with the color corresponding to cluster membership.

```{r}
dimFeature(obj, colorBy = cluster_id, reduction = "umap")
dimFeature(obj, colorBy = cluster_id, reduction = "tsne")
```

umapFeature uses ggplot logic, so you can adjust as needed. For example:

```{r}
dimFeature(obj, colorBy = cluster_id, colors = sample(pal)) + facet_wrap(vars(batch)) # Batch is made up to illustrate function utility
```

umapFeature is useful for looking at how the different parameters in the cellInfo file are distributed throughout the UMAP:

```{r}
dimFeature(obj, colorBy = log(cov)) + scale_color_gradientn(colors = c("black", "turquoise", "gold", "red")) # no coverage bias!
dimFeature(obj, colorBy = mcg_pct) + scale_color_gradientn(colors = c("black", "turquoise", "gold", "red")) 
```

Show the distribution of cluster membership between samples with sampleComp. Make sure the parameters of interest are categorical variables in the metadata. Plots can be easily modified with ggplot command logic.

```{r}
sampleComp(obj, groupBy = "batch", colorBy = "cluster_id", colors = pal) 
```



```{r}
cluster500bpwindows <- calcSmoothedWindows(obj, type = "CG", threads = 1, step = 500, species = "human", 
                                           index = "chr_cg", groupBy = "cluster_id", returnSumMatrix = T, returnPctMatrix = T)
obj@genomeMatrices[["cg_cluster_tracks"]] <- cluster500bpwindows[["pct_matrix"]]
```

While still on the server, we will run DMR analysis as an example. In reality, you will probably want to validate the groups before completing this step.
eachVsAll tests observations for each group at a time versus the rest.

```{r}
dmrs <- testDMR(sumMatrix = cluster500bpwindows[["sum_matrix"]], eachVsAll = TRUE, nminTotal = 5, nminGroup = 5)
```

If specific comparisons are desired, a data frame can be provided describing the tests. Three columns should be included: One listing members of group A, one listing members of group B, and one with the name of the test.

```{r}
comparisons <- data.frame(
  stringsAsFactors = FALSE,
              name = c("test1", "test2", "test3"),
                 A = c("1,2,3", "1", "2,3"),
                 B = c("4,5", "6", "1")
)
dmrs <- testDMR(sumMatrix = cluster500bpwindows[["sum_matrix"]], comparisons = comparisons, nminTotal = 5, nminGroup = 5)
```

Then expand and filter the resulting list according to the desired stringency.

```{r}
dmrs <- filterDMR(dmrs, method = "bonferroni", filter = TRUE, pThreshold = 0.01, logThreshold = 2)
```

########################################################################################################
### INVESTIGATING METHYLATION OVER SPECIFIC GENES ### 


```{r}
obj@ref <- makeRef(ref = "hg38") # mm10 is also an option
```

Now let's look at methylation levels over key marker genes in relation to the UMAP.
Look at sigmarkers results to explore other genes.

```{r}
dimM(obj, genes = c("GAD1", "SATB2", "LINGO1", "SLC17A8"), matrix = "gene_ch") 
dimM(obj, genes = c("GAD1", "SATB2"), matrix = "gene_ch", blend = T, pointSize = 0.8) # these two are pretty mutually exclusive
```

Visualization can also be easily done with violin plots or dot plots

```{r}
violinM(obj, genes = c("SATB2", "GAD1"), groupBy = "cluster_id", nrow = 2, matrix = "gene_ch")
dotM(obj, genes = c("SATB2", "GAD1"), matrix = "gene_ch", groupBy = "cluster_id")
```

Since single-cell methylation data can be low coverage, it may be helpful to impute values.
If having trouble downloading Rmagic, try devtools::install_github("KrishnaswamyLab/MAGIC/Rmagic")

```{r}
obj@genomeMatrices[["gene_ch_imputed"]] <- impute(obj, matrix = "gene_ch", replaceNA = "mch_pct") 
```

Then use the resulting matrix to compare imputed vs. non-imputed values

```{r}
dimM(obj, genes = c("SLC17A8"), matrix = "gene_ch", pointSize = 0.8)
dimM(obj, genes = c("SLC17A8"), matrix = "gene_ch_imputed", pointSize = 0.8) 
```

Visualization of methylation over the gene body can be done with histograM or heatMap

```{r}
heatMap(obj, genes = c("CD2", "CD3G"), matrix = "cg_cluster_tracks", legend = F)
heatMap(obj, genes = c("MOG", "C1QA", "GAD1", "SLC17A7", "SST", "AQP4"), matrix = "cg_cluster_tracks", nrow = 3, removeNA = F) 
```

Variation in methylation levels of key marker genes can help aid in cell type ID, but it may be more effective to compare to a reference. If using brain data you can use clusterCompare to correlate % methylation over 100kb genomic windows to a reference generated from Liu 2021 (Ecker lab). Levels to compare with are:
"region_name"  "major_region" "sub_region"   "cell_class"   "major_type"   "sub_type" 

First, generate an aggregated matrix of values over some metadata parameter.

```{r}
obj <- aggregateMatrix(obj, matrix = "ch_100k_pct", groupBy = cluster_id, name = "cluster_ch_100k_pct") # Already added if using /home/groups/ravnica/projects/amethyst/sciMETv2_braindata/brain_vignette_workspace.RData
clusterCompare("cluster_ch_100k_pct", level = "major_type", type = "ch", n = 5) # Correlation very low because it is human vs. mouse. Still working on this
```

Coming up:
- Trajectory analysis
- DMR identification
- Open to suggestions



testPalette("umap", obj = obj)



